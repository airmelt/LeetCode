# 2875 Minimum Size Subarray in Infinite Array 无限数组的最短子数组

__Description:__

You are given a __0-indexed__ array `nums` and an integer `target`.

A __0-indexed__ array `infinite_nums` is generated by infinitely appending the elements of `nums` to itself.

Return _the length of the __shortest__ subarray of the array_ `infinite_nums` _with a sum equal to_ `target`_._ If there is no such subarray return `-1`.

__Example:__

Example 1:

```text
Input: nums = [1,2,3], target = 5
Output: 2
Explanation: In this example infinite_nums = [1,2,3,1,2,3,1,2,...].
The subarray in the range [1,2], has the sum equal to target = 5 and length = 2.
It can be proven that 2 is the shortest length of a subarray with sum equal to target = 5.
```

Example 2:

```text
Input: nums = [1,1,1,2,3], target = 4
Output: 2
Explanation: In this example infinite_nums = [1,1,1,2,3,1,1,1,2,3,1,1,...].
The subarray in the range [4,5], has the sum equal to target = 4 and length = 2.
It can be proven that 2 is the shortest length of a subarray with sum equal to target = 4.
```

Example 3:

```text
Input: nums = [2,4,6,8], target = 3
Output: -1
Explanation: In this example infinite_nums = [2,4,6,8,2,4,6,8,...].
It can be proven that there is no subarray with sum equal to target = 3.
```

__Constraints:__

- `1 <= nums.length <= 10 ^ 5`
- `1 <= nums[i] <= 10 ^ 5`
- `1 <= target <= 10 ^ 9`

__题目描述:__

给你一个下标从 __0__ 开始的数组 `nums` 和一个整数 `target` 。

下标从 __0__ 开始的数组 `infinite_nums` 是通过无限地将 nums 的元素追加到自己之后生成的。

请你从 `infinite_nums` 中找出满足 __元素和__ 等于 `target` 的 __最短__ 子数组，并返回该子数组的长度。如果不存在满足条件的子数组，返回 `-1` 。

__示例:__

示例 1：

```text
输入：nums = [1,2,3], target = 5
输出：2
解释：在这个例子中 infinite_nums = [1,2,3,1,2,3,1,2,...] 。
区间 [1,2] 内的子数组的元素和等于 target = 5 ，且长度 length = 2 。
可以证明，当元素和等于目标值 target = 5 时，2 是子数组的最短长度。
```

示例 2：

```text
输入：nums = [1,1,1,2,3], target = 4
输出：2
解释：在这个例子中 infinite_nums = [1,1,1,2,3,1,1,1,2,3,1,1,...].
区间 [4,5] 内的子数组的元素和等于 target = 4 ，且长度 length = 2 。
可以证明，当元素和等于目标值 target = 4 时，2 是子数组的最短长度。
```

示例 3：

```text
输入：nums = [2,4,6,8], target = 3
输出：-1
解释：在这个例子中 infinite_nums = [2,4,6,8,2,4,6,8,...] 。
可以证明，不存在元素和等于目标值 target = 3 的子数组。
```

__提示：__

- `1 <= nums.length <= 10 ^ 5`
- `1 <= nums[i] <= 10 ^ 5`
- `1 <= target <= 10 ^ 9`

__思路:__

```text
前缀和/滑动窗口
将数组的前缀和对应的下标放入哈希表中
由于数组是无限的, 当需要检查的 cur = target + x 比数组的和还要大时
可以对其取余得到 k
遍历前缀和数组检查 k 是否在哈希表中
如果在哈希表中, 那么其下标的长度就为 d[k] - i
然后再加上 cur / s 个数组长度, 这里需要特判一下 cur 是否在哈希表中防止 0 和数组和都在哈希表中干扰计算
时间复杂度为 O(N), 空间复杂度为 O(N)
```

__代码:__

__C++__:

```C++
class Solution 
{
public:
    int minSizeSubarray(vector<int>& nums, int target) 
    {
        unordered_map<long long, int> d;
        int n = nums.size(), result = INT_MAX;
        vector<long long> pre(n + 1);
        long long s = accumulate(nums.begin(), nums.end(), 0LL), cur = 0LL, k = 0LL;
        for (int i = 0; i < n; i++) 
        {
            pre[i + 1] = pre[i] + nums[i];
            d[pre[i + 1]] = i + 1;
        }
        d[pre.front()] = 0;
        for (int i = 0; i <= n; i++) 
        {
            cur = k = target + pre[i];
            if (k > s) k %= s;
            if (d.count(k)) result = min(result, (int)(d[k] - i + ((cur - (d.count(cur) ? 1LL : 0LL)) / s) * n));
        }
        return result == INT_MAX ? -1 : result;
    }
};
```

__Java__:

```Java
class Solution {
    public int minSizeSubarray(int[] nums, int target) {
        var d = new HashMap<Long, Integer>();
        int n = nums.length, result = Integer.MAX_VALUE;
        long pre[] = new long[n + 1], s = Arrays.stream(nums).mapToLong(v -> v).sum(), cur = 0L, k = 0L;
        for (int i = 0; i < n; i++) {
            pre[i + 1] = pre[i] + nums[i];
            d.put(pre[i + 1], i + 1);
        }
        d.put(pre[0], 0);
        for (int i = 0; i <= n; i++) {
            cur = k = target + pre[i];
            if (k > s) k %= s;
            if (d.containsKey(k)) result = Math.min(result, (int)(d.get(k) - i + ((cur - (d.containsKey(cur) ? 1L : 0L)) / s) * n));
        }
        return result == Integer.MAX_VALUE ? -1 : result;
    }
}
```

__Python__:

```Python
class Solution:
    def minSizeSubarray(self, nums: List[int], target: int) -> int:
        n, pre, d, result, s = len(nums), [0] + list(accumulate(nums)), { v: i for i, v in enumerate([0] + list(accumulate(nums))) }, inf, sum(nums)
        for i, x in enumerate(pre):
            if (cur := (target + x) % s if (target + x) > s else target + x) in d:
                result = min(result, d[cur] - i + ((target + x - (target + x in d)) // s) * n)
        return result if result < inf else -1
```
