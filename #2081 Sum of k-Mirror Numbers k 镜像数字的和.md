# 2081 Sum of k-Mirror Numbers k 镜像数字的和

__Description:__

A k-mirror number is a positive integer without leading zeros that reads the same both forward and backward in base-10 as well as in base-k.

- For example, `9` is a 2-mirror number. The representation of `9` in base-10 and base-2 are `9` and `1001` respectively, which read the same both forward and backward.
- On the contrary, `4` is not a 2-mirror number. The representation of `4` in base-2 is `100`, which does not read the same both forward and backward.

Given the base `k` and the number `n`, return _the __sum__ of the_ `n` ___smallest__ k-mirror numbers_.

__Example:__

Example 1:

```text
Input: k = 2, n = 5
Output: 25
Explanation:
The 5 smallest 2-mirror numbers and their representations in base-2 are listed as follows:
  base-10    base-2
    1          1
    3          11
    5          101
    7          111
    9          1001
Their sum = 1 + 3 + 5 + 7 + 9 = 25.
```

Example 2:

```text
Input: k = 3, n = 7
Output: 499
Explanation:
The 7 smallest 3-mirror numbers are and their representations in base-3 are listed as follows:
  base-10    base-3
    1          1
    2          2
    4          11
    8          22
    121        11111
    151        12121
    212        21212
Their sum = 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499.
```

Example 3:

```text
Input: k = 7, n = 17
Output: 20379000
Explanation: The 17 smallest 7-mirror numbers are:
1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596
```

__Constraints:__

- `2 <= k <= 9`
- `1 <= n <= 30`

__题目描述:__

一个 k 镜像数字 指的是一个在十进制和 k 进制下从前往后读和从后往前读都一样的 没有前导 0 的 正 整数。

- 比方说， `9` 是一个 2 镜像数字。 `9` 在十进制下为 `9` ，二进制下为 `1001` ，两者从前往后读和从后往前读都一样。
- 相反地， `4` 不是一个 2 镜像数字。 `4` 在二进制下为 `100` ，从前往后和从后往前读不相同。

给你进制 `k` 和一个数字 `n` ，请你返回 k 镜像数字中 __最小__ 的 `n` 个数 __之和__ 。

__示例:__

示例 1：

```text
输入：k = 2, n = 5
输出：25
解释：
最小的 5 个 2 镜像数字和它们的二进制表示如下：
  十进制       二进制
    1          1
    3          11
    5          101
    7          111
    9          1001
它们的和为 1 + 3 + 5 + 7 + 9 = 25 。
```

示例 2：

```text
输入：k = 3, n = 7
输出：499
解释：
7 个最小的 3 镜像数字和它们的三进制表示如下：
  十进制       三进制
    1          1
    2          2
    4          11
    8          22
    121        11111
    151        12121
    212        21212
它们的和为 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499 。
```

示例 3：

```text
输入：k = 7, n = 17
输出：20379000
解释：17 个最小的 7 镜像数字分别为：
1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596
```

__提示：__

- `2 <= k <= 9`
- `1 <= n <= 30`

__思路:__

```text
1. 模拟(Java)
检查 10 进制下的回文数是否也是 k 进制下的回文数
由于 10 进制下该数是回文数, 可以只用检查一半(奇数和偶数分情况讨论)
比如 123 可以转换为 12321, 或者 123321
检查 k 进制下的回文数可以直接将 10 进制数转换为 k 进制数, 再检查是否是回文数
时间复杂度为 O(ClogC), 空间复杂度为 O(1), 其中 C 为最大的回文数, 本题中 ClogC 为 10 ^ 5
2. 打表
由于最多只需要 30 * 8 个数, 可以直接打表
由方法 1 得到的结果
时间复杂度为 O(1), 空间复杂度为 O(1)
```

__代码:__

__C++__:

```C++
class Solution 
{
public:
    long long kMirror(int k, int n) 
    {
        return vector<vector<long long>>{{1LL, 4LL, 9LL, 16LL, 25LL, 58LL, 157LL, 470LL, 1055LL, 1772LL, 9219LL, 18228LL, 33579LL, 65802LL, 105795LL, 159030LL, 212865LL, 286602LL, 872187LL, 2630758LL, 4565149LL, 6544940LL, 9674153LL, 14745858LL, 20005383LL, 25846868LL, 39347399LL, 759196316LL, 1669569335LL, 2609044274L},{1LL, 3LL, 7LL, 15LL, 136LL, 287LL, 499LL, 741LL, 1225LL, 1881LL, 2638LL, 31730LL, 80614LL, 155261LL, 230718LL, 306985LL, 399914LL, 493653LL, 1342501LL, 2863752LL, 5849644LL, 9871848LL, 14090972LL, 18342496LL, 22630320LL, 28367695LL, 36243482LL, 44192979LL, 71904751LL, 155059889L},{1LL, 3LL, 6LL, 11LL, 66LL, 439LL, 832LL, 1498LL, 2285LL, 3224LL, 11221LL, 64456LL, 119711LL, 175366LL, 233041LL, 739646LL, 2540727LL, 4755849LL, 8582132LL, 12448815LL, 17500320LL, 22726545LL, 27986070LL, 33283995LL, 38898160LL, 44577925LL, 98400760LL, 721411086LL, 1676067545LL, 53393239260L},{1LL, 3LL, 6LL, 10LL, 16LL, 104LL, 356LL, 638LL, 1264LL, 1940LL, 3161LL, 18912LL, 37793LL, 10125794LL, 20526195LL, 48237967LL, 78560270LL, 126193944LL, 192171900LL, 1000828708LL, 1832161846LL, 2664029984LL, 3500161622LL, 4336343260LL, 6849225412LL, 9446112364LL, 12339666346LL, 19101218022LL, 31215959143LL, 43401017264L},{1LL, 3LL, 6LL, 10LL, 15LL, 22LL, 77LL, 188LL, 329LL, 520LL, 863LL, 1297LL, 2074LL, 2942LL, 4383LL, 12050LL, 19827LL, 41849LL, 81742LL, 156389LL, 325250LL, 1134058LL, 2043967LL, 3911648LL, 7009551LL, 11241875LL, 15507499LL, 19806423LL, 24322577LL, 28888231L},{1LL, 3LL, 6LL, 10LL, 15LL, 21LL, 29LL, 150LL, 321LL, 563LL, 855LL, 17416LL, 83072LL, 2220384LL, 6822448LL, 13420404LL, 20379000LL, 29849749LL, 91104965LL, 321578997LL, 788407661LL, 1273902245LL, 1912731081LL, 2570225837LL, 3428700695LL, 29128200347LL, 69258903451LL, 115121130305LL, 176576075721LL, 241030621167L},{1LL, 3LL, 6LL, 10LL, 15LL, 21LL, 28LL, 37LL, 158LL, 450LL, 783LL, 1156LL, 1570LL, 2155LL, 5818LL, 14596LL, 27727LL, 41058LL, 67520LL, 94182LL, 124285LL, 154588LL, 362290LL, 991116LL, 1651182LL, 3148123LL, 5083514LL, 7054305LL, 11253219LL, 66619574L},{1LL, 3LL, 6LL, 10LL, 15LL, 21LL, 28LL, 36LL, 227LL, 509LL, 882LL, 1346LL, 1901LL, 2547LL, 3203LL, 10089LL, 35841LL, 63313LL, 105637LL, 156242LL, 782868LL, 2323319LL, 4036490LL, 5757761LL, 7586042LL, 9463823LL, 11349704LL, 13750746LL, 16185088LL, 18627530LL}}[k - 2][n - 1];
    }
};
```

__Java__:

```Java
class Solution {
    private int[] digit = new int[100];

    public long kMirror(int k, int n) {
        long left = 1L, count = 0, result = 0, right = 0;
        while (count < n) {
            right = left * 10;
            for (int odd = 0; odd < 2; odd++) {
                for (int i = (int)left; i < right && count < n; i++) {
                    long cur = i;
                    int x = (odd == 0 ? i / 10 : i);
                    while (x != 0) {
                        cur = cur * 10 + x % 10;
                        x /= 10;
                    }
                    if (check(cur, k)) {
                        ++count;
                        result += cur;
                    }
                }
            }
            left = right;
        }
        return result;
    }

    private boolean check(long x, int k) {
        int size = -1;
        while (x != 0) {
            digit[++size] = (int)(x % (long)k);
            x /= k;
        }
        for (int i = 0; i < size; ++i, --size) if (digit[i] != digit[size]) return false;
        return true;
    }
}
```

__Python__:

```Python
class Solution:
    def kMirror(self, k: int, n: int) -> int:
        return sum([[1, 3, 5, 7, 9, 33, 99, 313, 585, 717, 7447, 9009, 15351, 32223, 39993, 53235, 53835, 73737, 585585, 1758571, 1934391, 1979791, 3129213, 5071705, 5259525, 5841485, 13500531, 719848917, 910373019, 939474939],[1, 2, 4, 8, 121, 151, 212, 242, 484, 656, 757, 29092, 48884, 74647, 75457, 76267, 92929, 93739, 848848, 1521251, 2985892, 4022204, 4219124, 4251524, 4287824, 5737375, 7875787, 7949497, 27711772, 83155138],[1, 2, 3, 5, 55, 373, 393, 666, 787, 939, 7997, 53235, 55255, 55655, 57675, 506605, 1801081, 2215122, 3826283, 3866683, 5051505, 5226225, 5259525, 5297925, 5614165, 5679765, 53822835, 623010326, 954656459, 51717171715],[1, 2, 3, 4, 6, 88, 252, 282, 626, 676, 1221, 15751, 18881, 10088001, 10400401, 27711772, 30322303, 47633674, 65977956, 808656808, 831333138, 831868138, 836131638, 836181638, 2512882152, 2596886952, 2893553982, 6761551676, 12114741121, 12185058121],[1, 2, 3, 4, 5, 7, 55, 111, 141, 191, 343, 434, 777, 868, 1441, 7667, 7777, 22022, 39893, 74647, 168861, 808808, 909909, 1867681, 3097903, 4232324, 4265624, 4298924, 4516154, 4565654],[1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596, 9470749, 61255216, 230474032, 466828664, 485494584, 638828836, 657494756, 858474858, 25699499652, 40130703104, 45862226854, 61454945416, 64454545446],[1, 2, 3, 4, 5, 6, 7, 9, 121, 292, 333, 373, 414, 585, 3663, 8778, 13131, 13331, 26462, 26662, 30103, 30303, 207702, 628826, 660066, 1496941, 1935391, 1970791, 4198914, 55366355],[1, 2, 3, 4, 5, 6, 7, 8, 191, 282, 373, 464, 555, 646, 656, 6886, 25752, 27472, 42324, 50605, 626626, 1540451, 1713171, 1721271, 1828281, 1877781, 1885881, 2401042, 2434342, 2442442]][k - 2][:n])
```
